import process from 'node:process';
import path from 'node:path';

import { serve } from '@hono/node-server';
import crosswsNode from 'crossws/adapters/node';
import type { Server } from 'node:http';

import { initApp } from 'springboard/server/hono_app';
import { makeWebsocketServerCoreDependenciesWithSqlite } from 'springboard/platforms/node/services/ws_server_core_dependencies';
import { LocalJsonNodeKVStoreService } from 'springboard/platforms/node/services/node_kvstore_service';
import { CoreDependencies, Springboard } from 'springboard/core';
import '__USER_ENTRY__';

/**
 * Node.js server entrypoint with HMR support
 *
 * This file is generated by the Springboard Vite plugin and serves as the
 * entry point for the Node.js dev server. It:
 *
 * 1. Imports the user's application entry (which registers modules)
 * 2. Exports start/stop functions for lifecycle management
 * 3. Supports HMR via import.meta.hot.dispose()
 */

let server: Server | null = null;
let engine: Springboard | null = null;

/**
 * Start the node server
 */
export async function start() {
  // If server is already running, stop it first
  if (server) {
    await stop();
  }

  try {
    const webappFolder = process.env.WEBAPP_FOLDER || './dist/browser';
    const webappDistFolder = path.join(webappFolder, './dist');

    const nodeKvDeps = await makeWebsocketServerCoreDependenciesWithSqlite();
    const useWebSocketsForRpc = import.meta.env.VITE_USE_WEBSOCKETS_FOR_RPC === 'true';

    let wsNode: ReturnType<typeof crosswsNode>;

    const { app, serverAppDependencies, injectResources, createWebSocketHooks } = initApp({
      broadcastMessage: (message) => {
        return wsNode.publish('event', message);
      },
      remoteKV: nodeKvDeps.kvStoreFromKysely,
      userAgentKV: new LocalJsonNodeKVStoreService('userAgent'),
    });

    wsNode = crosswsNode({
      hooks: createWebSocketHooks(useWebSocketsForRpc),
    });

    // Use configured port (ignores process.env.PORT to avoid conflicts)
    const port = __PORT__;

    // Start the HTTP server
    server = serve({
      fetch: app.fetch,
      port,
    }, (info) => {
      console.log(`Server listening on http://localhost:${info.port}`);
    });

    server.on('upgrade', (request, socket, head) => {
      const url = new URL(request.url || '', `http://${request.headers.host}`);
      if (url.pathname === '/ws') {
        wsNode.handleUpgrade(request, socket, head);
      } else {
        socket.end('HTTP/1.1 404 Not Found\r\n\r\n');
      }
    });

    const coreDeps: CoreDependencies = {
      log: console.log,
      showError: console.error,
      storage: serverAppDependencies.storage,
      isMaestro: () => true,
      rpc: serverAppDependencies.rpc,
    };

    Object.assign(coreDeps, serverAppDependencies);

    const extraDeps = {}; // TODO: remove this extraDeps thing from the framework

    engine = new Springboard(coreDeps, extraDeps);

    injectResources({
      engine,
      serveStaticFile: async (c, fileName, headers) => {
        try {
          const fullPath = `${webappDistFolder}/${fileName}`;
          const fs = await import('node:fs');
          const data = await fs.promises.readFile(fullPath, 'utf-8');
          c.status(200);

          if (headers) {
            Object.entries(headers).forEach(([key, value]) => {
              c.header(key, value);
            });
          }

          return c.body(data);
        } catch (error) {
          console.error('Error serving file:', error);
          c.status(404);
          return c.text('404 Not found');
        }
      },
      getEnvValue: name => process.env[name],
    });

    await engine.initialize();
    console.log('Node application started successfully');
  } catch (error) {
    console.error('Failed to start node server:', error);
    throw error;
  }
}

/**
 * Stop the node server
 */
export async function stop() {
  if (!server) {
    return;
  }

  return new Promise<void>((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('Server close timeout'));
    }, 5000);

    server!.close((err) => {
      clearTimeout(timeout);
      if (err) {
        reject(err);
      } else {
        console.log('Server stopped successfully');
        server = null;
        engine = null; // TODO: add explicit shutdown once the engine exposes it
        resolve();
      }
    });
  });
}

// HMR support: clean up before module reload
if (import.meta.hot) {
  import.meta.hot.dispose(async () => {
    console.log('[HMR] Stopping server before reload...');
    await stop();
  });
}

// Auto-start in production builds (not in dev mode)
if (!import.meta.env.DEV) {
  start().catch(console.error);
}
